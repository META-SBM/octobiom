#' Generate Pairwise Subsets of a Phyloseq Object
#'
#' Creates pairwise subsets of a phyloseq object based on factor levels in a specified metadata column.
#' Useful for differential abundance analysis between groups.
#'
#' @param ps_obj A [`phyloseq::phyloseq-class`] object containing microbiome data.
#' @param column Character. Name of the metadata column to use for grouping (must be a factor).
#'
#' @return A list with three elements:
#' * `ps_obj_list`: List of subsetted phyloseq objects (one per pairwise combination)
#' * `contrasts`: List of contrast vectors formatted for DESeq2 (`c("variable", "reference", "target")`)
#' * `formatted_names`: Vector of human-readable contrast names (e.g., "GroupA_vs_GroupB")
#'
#' @examples
#' \dontrun{
#' # Example with GlobalPatterns dataset
#' data(GlobalPatterns)
#' subsets <- generate_pairwise_subsets(GlobalPatterns, "SampleType")
#' }
#'
#' @importFrom phyloseq sample_data prune_samples
#' @importFrom utils combn
#' @export
generate_pairwise_subsets <- function(ps_obj, column) {
  # Ensure the column exists in the sample data
  if (!(column %in% colnames(sample_data(ps_obj)))) {
    stop(paste("The specified",column,"column does not exist in the sample data."))
  }

  # Check and print the levels of the phenotype column
  phenotype_levels <- levels(factor(sample_data(ps_obj)[[column]]))
  print(paste("Levels of the", column, "column:"))
  print(phenotype_levels)

  # Generate pairwise combinations of the phenotype levels
  comb_list <- combn(phenotype_levels, 2, simplify = FALSE)

  # Create a list to store the subsetted phyloseq objects
  ps_obj_list <- list()

  for (comb in comb_list) {
    # Create the subsetting condition for the current combination
    subset_condition <- sample_data(ps_obj)[[column]] %in% comb

    # Subset the phyloseq object for the current combination
    subset_ps_obj <- prune_samples(subset_condition, ps_obj)

    # Update factor levels in the subsetted sample data
    sample_data(subset_ps_obj)[[column]] <- factor(sample_data(subset_ps_obj)[[column]], levels = comb)

    # Add the subsetted phyloseq object to the list
    comb_name <- paste(comb, collapse = "_")
    ps_obj_list[[comb_name]] <- subset_ps_obj
  }

  # Generate contrasts for DESeq2
  contrasts <- lapply(comb_list, function(comb) c(column, comb[1], comb[2]))
  formatted_names <- sapply(comb_list, function(comb) paste(comb, collapse = "_"))

  return(list(ps_obj_list = ps_obj_list, contrasts = contrasts, formatted_names = formatted_names))
}
#' Run MaAsLin2 on Phyloseq Subsets
#'
#' Applies MaAsLin2 microbiome analysis to a list of phyloseq subsets generated by
#' [`generate_pairwise_subsets`]. Automatically processes all pairwise comparisons.
#'
#' @param ps_obj_list List of [`phyloseq::phyloseq-class`] objects from [`generate_pairwise_subsets`]
#' @param fixed_effects Character vector of metadata columns to include as fixed effects
#' @param normalization Normalization method (default: "NONE"). See [`Maaslin2::Maaslin2`]
#' @param transform Transformation method (default: "NONE"). See [`Maaslin2::Maaslin2`]
#' @param analysis_method Statistical method (default: "CPLM"). See [`Maaslin2::Maaslin2`]
#' @param max_significance FDR threshold for significant results (default: 0.05)
#' @param output_dir Output directory path (default: "Maaslin2_Results")
#' @param ncores Number of CPU cores for parallel processing
#'
#' @return List of MaAsLin2 results objects. Each element contains:
#' * Full MaAsLin2 output in specified directory
#' * Results table with coefficients, p-values, and q-values
#'
#' @examples
#' \dontrun{
#' results <- apply_maaslin2(
#'   subsets$ps_obj_list,
#'   fixed_effects = c("BMI"),
#'   ncores = 4
#' )
#' }
#'
#' @importFrom phyloseq otu_table sample_data
#' @importFrom Maaslin2 Maaslin2
#' @importFrom dplyr %>%
#' @export
apply_maaslin2 <- function(ps_obj_list, fixed_effects, normalization ,
                           transform ,
                           analysis_method,
                           max_significance = 0.05,
                           output_dir = "Maaslin2_Results",ncores,
                           reference = NULL) {

  # Ensure the output directory exists
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  fit_list <- list()
  # Process each method
  all_results <- list()

  for (name in names(ps_obj_list)) {
    ps_obj <- ps_obj_list[[name]]

    # Prepare input data for MaAsLin2
    inputdata <- phyloseq::otu_table(ps_obj) %>%
      data.frame() %>%
      t() %>%
      data.frame()

    input_metadata <- phyloseq::sample_data(ps_obj) %>%
      data.frame()

    # Define the output path for this subset
    output_path <- file.path(output_dir, paste0(name, "_maaslin2"))
    if(!is.null(reference)){
      # Fit MaAsLin2 model
      fit <- Maaslin2(
        input_data = inputdata,
        input_metadata = input_metadata,
        output = output_path,
        fixed_effects = fixed_effects,
        normalization = normalization,
        transform = transform,
        analysis_method = analysis_method,
        max_significance = max_significance,
        correction = "BH",
        cores=ncores,
        reference = reference
      )
    } else {
      # Fit MaAsLin2 model
      fit <- Maaslin2(
        input_data = inputdata,
        input_metadata = input_metadata,
        output = output_path,
        fixed_effects = fixed_effects,
        normalization = normalization,
        transform = transform,
        analysis_method = analysis_method,
        max_significance = max_significance,
        correction = "BH",
        cores=ncores
      )
    }

    # Add the fit to the list
    fit_list[[name]] <- fit
  }

  return(fit_list)
}
#' Run MaAsLin2 with Multiple Processing Methods
#'
#' @param ps_obj Phyloseq object
#' @param contrasts List of contrasts (if NULL, auto-generate from comparison_group)
#' @param methods List of method configurations (analysis_method, normalization, transform)
#' @param output_dir Output directory
#' @param fixed_effects Fixed effects for the model
#' @param reference Reference level for comparisons (format: c("variable", "level"))
#' @param ncores Number of CPU cores
#' @param comparison_group Grouping variable for auto-generating contrasts
#'
#' @return Consolidated results with all methods and comparisons
#' @export
process_maaslin <- function(ps_obj,
                            contrasts = NULL,
                            methods = list(
                              list(analysis_method = "CPLM",
                                   normalization = "TSS",
                                   transform = "NONE")
                            ),
                            output_dir = "maaslin_results",
                            fixed_effects,
                            reference = NULL,
                            ncores = 1,
                            comparison_group = NULL) {

  # Generate contrasts if not provided
  if(is.null(contrasts) && !is.null(comparison_group)) {
    subsets <- generate_pairwise_subsets(ps_obj, comparison_group)
    contrasts <- subsets$contrasts
    ps_obj_list <- subsets$ps_obj_list
  } else {
    stop("Either provide contrasts or specify comparison_group")
  }


  # Process each method
  all_results <- list()

  for(method in methods) {
    method_name <- paste(
      method$analysis_method,
      method$normalization,
      method$transform,
      sep = "_"
    )

    method_dir <- file.path(output_dir, method_name)

    # Run MaAsLin2 for all contrasts with current method
    if(!is.null(reference)){
      method_results <- apply_maaslin2(
        ps_obj_list = ps_obj_list,
        fixed_effects = fixed_effects,
        normalization = method$normalization,
        transform = method$transform,
        analysis_method = method$analysis_method,
        output_dir = method_dir,
        ncores = ncores,
        reference = reference
      )
    } else {
      method_results <- apply_maaslin2(
        ps_obj_list = ps_obj_list,
        fixed_effects = fixed_effects,
        normalization = method$normalization,
        transform = method$transform,
        analysis_method = method$analysis_method,
        output_dir = method_dir,
        ncores = ncores
      )
    }

    # Store results with method metadata
    for(contrast_name in names(method_results)) {
      method_results[[contrast_name]]$comparison <- contrast_name
      method_results[[contrast_name]] <- method_results[[contrast_name]]
      all_results[[contrast_name]] <- append(
        all_results[[contrast_name]],
        list(
          method_results[[contrast_name]]$results %>%
            mutate(model = method_name)
        )
      )
    }
  }
  # Combine results across methods for each contrast
  consolidated <- lapply(all_results, function(x) {
    do.call(rbind, x) %>%  # Базовый rbind сохраняет класс data.frame
      dplyr::arrange(feature, model)
  })
  all_df <- dplyr::bind_rows(consolidated, .id = "comparison")
  write.csv(all_df, file = file.path(output_dir, "results.csv"), row.names = FALSE)
  return(consolidated)
}
